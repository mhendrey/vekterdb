<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>VekterDB &mdash; VekterDB 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js?v=f6245a2f"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="vekterdb.vekterdb" href="modules.html" />
    <link rel="prev" title="VekterDB" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            VekterDB
          </a>
              <div class="version">
                0.0.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Usage</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">VekterDB</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#the-basics">The Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="#usage">Usage</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tutorial">Tutorial</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#set-up">Set up</a></li>
<li class="toctree-l3"><a class="reference internal" href="#initialize-vekterdb">Initialize VekterDB</a></li>
<li class="toctree-l3"><a class="reference internal" href="#insert-records-into-the-db-table">Insert Records into the DB Table</a></li>
<li class="toctree-l3"><a class="reference internal" href="#create-faiss-index">Create FAISS Index</a></li>
<li class="toctree-l3"><a class="reference internal" href="#querying-for-similar-vectors">Querying for Similar Vectors</a></li>
<li class="toctree-l3"><a class="reference internal" href="#querying-for-similar-records">Querying for Similar Records</a></li>
<li class="toctree-l3"><a class="reference internal" href="#saving-loading-a-vekterdb">Saving &amp; Loading a VekterDB</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="modules.html">vekterdb.vekterdb</a><ul>
<li class="toctree-l2"><a class="reference internal" href="modules.html#vekterdb.vekterdb.VekterDB"><code class="docutils literal notranslate"><span class="pre">VekterDB</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="modules.html#vekterdb.vekterdb.VekterDB.create_index"><code class="docutils literal notranslate"><span class="pre">VekterDB.create_index()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="modules.html#vekterdb.vekterdb.VekterDB.deserialize_vector"><code class="docutils literal notranslate"><span class="pre">VekterDB.deserialize_vector()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="modules.html#vekterdb.vekterdb.VekterDB.fetch_records"><code class="docutils literal notranslate"><span class="pre">VekterDB.fetch_records()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="modules.html#vekterdb.vekterdb.VekterDB.insert"><code class="docutils literal notranslate"><span class="pre">VekterDB.insert()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="modules.html#vekterdb.vekterdb.VekterDB.load"><code class="docutils literal notranslate"><span class="pre">VekterDB.load()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="modules.html#vekterdb.vekterdb.VekterDB.nearest_neighbors"><code class="docutils literal notranslate"><span class="pre">VekterDB.nearest_neighbors()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="modules.html#vekterdb.vekterdb.VekterDB.sample_vectors"><code class="docutils literal notranslate"><span class="pre">VekterDB.sample_vectors()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="modules.html#vekterdb.vekterdb.VekterDB.save"><code class="docutils literal notranslate"><span class="pre">VekterDB.save()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="modules.html#vekterdb.vekterdb.VekterDB.search"><code class="docutils literal notranslate"><span class="pre">VekterDB.search()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="modules.html#vekterdb.vekterdb.VekterDB.serialize_vector"><code class="docutils literal notranslate"><span class="pre">VekterDB.serialize_vector()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="modules.html#vekterdb.vekterdb.VekterDB.set_faiss_runtime_parameters"><code class="docutils literal notranslate"><span class="pre">VekterDB.set_faiss_runtime_parameters()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="modules.html#vekterdb.vekterdb.VekterDB.similarity"><code class="docutils literal notranslate"><span class="pre">VekterDB.similarity()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Admin</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="license.html">License</a><ul>
<li class="toctree-l2"><a class="reference internal" href="license.html#license-requirements">License Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="license.html#license-notices">License notices</a></li>
<li class="toctree-l2"><a class="reference internal" href="license.html#copyright">Copyright</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="help.html">Help</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">VekterDB</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">VekterDB</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/vekterdb.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="vekterdb">
<h1>VekterDB<a class="headerlink" href="#vekterdb" title="Permalink to this heading"></a></h1>
<section id="the-basics">
<h2>The Basics<a class="headerlink" href="#the-basics" title="Permalink to this heading"></a></h2>
<p>Transform any <a class="reference external" href="https://www.sqlalchemy.org/">SQLAlchemy</a> compliant database into a
vector database by adding <strong>any</strong> type of a <a class="reference external" href="https://ai.meta.com/tools/faiss/">FAISS</a>
index to index the vectors in order to utilize the many different types of approximate
nearest neighbor (ANN) algorithms available in FAISS.</p>
<p>Almost all available vector databases only allow users to select a limited subset of
the ANN algorithms available in libraries like FAISS. The typical indices that are
permitted are Hierarchical Navigable Small-World (HNSW) or Inverted File System (IVF),
but both of these struggle to scale effectively beyond 10-100 million
vectors <a class="footnote-reference brackets" href="#f1" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#f2" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> <a class="footnote-reference brackets" href="#f3" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>. The aim of VekterDB is to provide users with greater
flexibility in terms of both the ANN index and the type of databases they can use.</p>
<p>VekterDB requires a minimum of two columns in the database table. The first is an
integer based identification [0, N) that is used by the FAISS index to refer to records
and serves as the primary key for the table. The second required column stores the
vector as bytes. Since VekterDB leverages FAISS, these vectors must be numpy arrays of
type float32. Of course, additional columns may be specified. For example, you may have
another column that serves as a more recognizable ID field that is a string.</p>
</section>
<section id="usage">
<h2>Usage<a class="headerlink" href="#usage" title="Permalink to this heading"></a></h2>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">vekterdb</span> <span class="kn">import</span> <span class="n">VekterDB</span>

<span class="c1"># Let&#39;s use some random data</span>
<span class="k">def</span> <span class="nf">generate_data</span><span class="p">(</span><span class="n">N</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">10_000</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span> <span class="n">seed</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">1024</span><span class="p">):</span>
    <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>
    <span class="n">vectors</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="c1"># Make vectors[1] be similar to vectors[0]</span>
    <span class="n">vectors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">vectors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">rng</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">vector</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vectors</span><span class="p">):</span>
        <span class="k">yield</span> <span class="p">{</span><span class="s2">&quot;idx&quot;</span><span class="p">:</span> <span class="n">idx</span><span class="p">,</span> <span class="s2">&quot;vector&quot;</span><span class="p">:</span> <span class="n">vector</span><span class="p">}</span>

<span class="n">records</span> <span class="o">=</span> <span class="n">generate_data</span><span class="p">()</span>

<span class="c1"># Create new table &quot;my_table&quot; in an in-memory SQLite database</span>
<span class="n">vekter_db</span> <span class="o">=</span> <span class="n">VekterDB</span><span class="p">(</span><span class="s2">&quot;my_table&quot;</span><span class="p">)</span>
<span class="c1"># Insert vectors into the database</span>
<span class="n">n_records</span> <span class="o">=</span> <span class="n">vekter_db</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">records</span><span class="p">)</span>

<span class="c1"># Create a Flat FAISS index and save it in the file &quot;my_table.index&quot;</span>
<span class="n">vekter_db</span><span class="o">.</span><span class="n">create_index</span><span class="p">(</span><span class="s2">&quot;my_table.index&quot;</span><span class="p">,</span> <span class="n">faiss_factory_str</span><span class="o">=</span><span class="s2">&quot;Flat&quot;</span><span class="p">)</span>

<span class="c1"># Let&#39;s find the 3 nearest neighbors of idx=0 and idx=1</span>
<span class="c1"># These should be each other</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">vekter_db</span><span class="o">.</span><span class="n">nearest_neighbors</span><span class="p">(</span><span class="s2">&quot;idx&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;idx&quot;</span><span class="p">)</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Outputs the following</span>
<span class="sd">[</span>
<span class="sd">    {&#39;idx&#39;: 0,</span>
<span class="sd">     &#39;neighbors&#39;: [</span>
<span class="sd">        {&#39;idx&#39;: 1, &#39;metric&#39;: 73.78341},</span>
<span class="sd">        {&#39;idx&#39;: 7537, &#39;metric&#39;: 39.142662},</span>
<span class="sd">        {&#39;idx&#39;: 9831, &#39;metric&#39;: 31.672077}</span>
<span class="sd">     ],</span>
<span class="sd">    },</span>
<span class="sd">    {&#39;idx&#39;: 1,</span>
<span class="sd">     &#39;neighbors&#39;: [</span>
<span class="sd">        {&#39;idx&#39;: 0, &#39;metric&#39;: 73.78341},</span>
<span class="sd">        {&#39;idx&#39;: 7537, &#39;metric&#39;: 38.97898},</span>
<span class="sd">        {&#39;idx&#39;: 9831, &#39;metric&#39;: 32.063244}</span>
<span class="sd">     ],</span>
<span class="sd">    },</span>
<span class="sd">]</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
</section>
<section id="tutorial">
<h2>Tutorial<a class="headerlink" href="#tutorial" title="Permalink to this heading"></a></h2>
<p>In this tutorial, we will work through an example using one of the datasets found in the
<a class="reference external" href="https://github.com/erikbern/ann-benchmarks?tab=readme-ov-file#data-sets">Approximate Nearest Neighbors Benchmark</a>, SIFT-1M.
The data is stored in an HDF5 file and can be downloaded from this <a class="reference external" href="http://ann-benchmarks.com/sift-128-euclidean.hdf5">link</a> (~500MB).</p>
<p>The sift-128-euclidean.hdf5 file has the following keys:</p>
<blockquote>
<div><ul class="simple">
<li><p>train : 1M 128-dimensional numpy vectors</p></li>
<li><p>test : 10,000 128-dimensional numpy vectors</p></li>
<li><dl class="simple">
<dt>neighbors<span class="classifier">10,000 x 100 that list the idx’s of top 100 neighbors of the</span></dt><dd><p>corresponding test vector</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>distances<span class="classifier">10,000 x 100 that list the Euclidean distance between test &amp; its</span></dt><dd><p>neighbors</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<section id="set-up">
<h3>Set up<a class="headerlink" href="#set-up" title="Permalink to this heading"></a></h3>
<p>We will begin by setting up a new conda environment and installing needed packages.
We need to install <a class="reference external" href="https://github.com/facebookresearch/faiss/blob/main/INSTALL.md#installing-faiss-via-conda">FAISS</a>
from conda and FAISS currently supports up to python 3.10 (see link if you want to use
your gpu).  We will also install h5py to be able to read the downloaded SIFT-1M
dataset.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ conda create -n vekterdb_tutorial python=3.10 ipython
$ conda activate vekterdb_tutorial
$ conda install -c pytorch -c conda-forge -c defaults h5py faiss-cpu=1.7.4 mkl=2021 blas=1.0=mkl
$ pip install vekterdb
$ ipython
</pre></div>
</div>
<p>The rest of the code assumes you are inside a Python interpretter (ipython, Jupyter,
or whatever you like).</p>
</section>
<section id="initialize-vekterdb">
<h3>Initialize VekterDB<a class="headerlink" href="#initialize-vekterdb" title="Permalink to this heading"></a></h3>
<p>We begin by initializing a VekterDB. For this tutorial, we will use a SQLite database,
but you could just as easily use a Postgres, MySQL, or any other of the SQLAlchemy
<a class="reference external" href="https://docs.sqlalchemy.org/en/20/dialects/index.html">dialects</a>. The SQLite
database will be stored in local file “sift1m.db” in a table called “tutorial”.
Though the h5py file has just the two required fields for VekterDB, namely an integer
identifier and the vector, we will add an additional string identifier for
demonstration purposes. This column will be indexed by SQLite in order to allow a
user to query for nearest neighbors using this identifier as well.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">h5py</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">sqlalchemy</span> <span class="k">as</span> <span class="nn">sa</span>
<span class="kn">from</span> <span class="nn">vekterdb</span> <span class="kn">import</span> <span class="n">VekterDB</span>

<span class="n">vekter_db</span> <span class="o">=</span> <span class="n">VekterDB</span><span class="p">(</span>
    <span class="s2">&quot;tutorial&quot;</span><span class="p">,</span>
    <span class="n">idx_name</span> <span class="o">=</span> <span class="s2">&quot;idx&quot;</span><span class="p">,</span>
    <span class="n">vector_name</span> <span class="o">=</span> <span class="s2">&quot;vector&quot;</span><span class="p">,</span>
    <span class="n">columns_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">sa</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">Text</span><span class="p">,</span> <span class="s2">&quot;unique&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;nullable&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
    <span class="p">},</span>
    <span class="n">url</span> <span class="o">=</span> <span class="s2">&quot;sqlite:///sift1m.db&quot;</span>
<span class="p">)</span>
</pre></div>
</div>
</section>
<section id="insert-records-into-the-db-table">
<h3>Insert Records into the DB Table<a class="headerlink" href="#insert-records-into-the-db-table" title="Permalink to this heading"></a></h3>
<p>With the database table, tutorial, now created in the database, sift1m.db, it is time
to add the records from the HDF5 file.  We will specify a function that will yield the
records that will be inserted into the database table. Since we haven’t specified a
FAISS index yet, these records will only be added to the database table.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">records_gen</span></code> is a good candidate for parallelization.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">records_gen</span><span class="p">(</span><span class="n">h5_file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">test_data</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">h5_file</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">test_data</span><span class="p">:</span>
            <span class="n">vectors</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;test&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vectors</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;train&quot;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">vector</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vectors</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">test_data</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1_000_000</span>
            <span class="k">yield</span> <span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="s2">&quot;idx&quot;</span><span class="p">:</span> <span class="n">i</span><span class="p">,</span> <span class="s2">&quot;vector&quot;</span><span class="p">:</span> <span class="n">vector</span><span class="p">}</span>


<span class="n">train_records</span> <span class="o">=</span> <span class="n">records_gen</span><span class="p">(</span><span class="s2">&quot;sift-128-euclidean.hdf5&quot;</span><span class="p">)</span>
<span class="n">n_records</span> <span class="o">=</span> <span class="n">vekter_db</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">train_records</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="create-faiss-index">
<h3>Create FAISS Index<a class="headerlink" href="#create-faiss-index" title="Permalink to this heading"></a></h3>
<p>With the database table now populated, we can construct the desired FAISS index which
handles the vector similarity queries. In this tutorial we will utilize a more
complicated index than is probably necessary, but we want to demonstrate using an index
appropriate for way more than 1M vectors.</p>
<p>For scalability, we will use an “IVF_HNSW,PQ” index.  Specifically, let’s use a
“IVF5000_HNSW32,PQ32” index. This splits the 128-dimensional space into
5 * sqrt(1_000_000) = 5,000 partitions. The centroids of the 5,000 partitions will
themselves be indexed using an HNSW32. To help save space, we will also use a Product
Quantization to shrink the size of each vector into ~ 32 bytes, down from 512 bytes.</p>
<p>The FAISS index will be saved to local disk in the “ivf_hnsw.index” file. The metric
is set to “L2” to match the Euclidean distance used for the SIFT-1M dataset. We use
all of the training data, 1M, to train the index. We pull 50,000 records from the
database at any one time and also insert into FAISS at this amount. When adding vectors
into the FAISS index, we will select the closest centroid from amongst a candidate pool
of the nearest 25 centroids. If we had used just an “IVF5000,PQ32” index, we would
compare each vector to all 5,000 centroids to determine which partition to insert
the vector.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vekter_db</span><span class="o">.</span><span class="n">create_index</span><span class="p">(</span>
    <span class="s2">&quot;ivf_hnsw.index&quot;</span><span class="p">,</span>
    <span class="s2">&quot;IVF5000_HNSW32,PQ32&quot;</span><span class="p">,</span>
    <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;L2&quot;</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="o">=</span><span class="mi">50_000</span><span class="p">,</span>
    <span class="n">faiss_runtime_params</span><span class="o">=</span><span class="s2">&quot;quantizer_efSearch=25&quot;</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</section>
<section id="querying-for-similar-vectors">
<h3>Querying for Similar Vectors<a class="headerlink" href="#querying-for-similar-vectors" title="Permalink to this heading"></a></h3>
<p>VekterDB offers two ways in which to query for nearest neighbors. The first handles the
cases when you have a vector that is <strong>not</strong> part of the database table, but want to
find the records in the database table that are the most similar to the query. This is
done with the <code class="docutils literal notranslate"><span class="pre">search()</span></code> method.  The second is when you want to find the nearest
neighbors in the database table to an existing record in the table. This is done with
the <code class="docutils literal notranslate"><span class="pre">nearest_neighbors()</span></code> method.</p>
<p>So far, we have only added the training data to the database and then used all those
vectors to train the FAISS index. We begin by getting reading the testing data from the
file and then using those to query our vector database for similar records.  We will
compare those to the “neighbors” stored in the HDF5 file. Let’s start slow and just
use the first test vector and get the five nearest neighbors. Since the FAISS
<code class="docutils literal notranslate"><span class="pre">index.search()</span></code> requires that the vector shape be at least (n, d), we reshape the
first vector to match. To easily compare, we only need to see the “idx” column.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">search()</span></code> returns a list with one element for each of the query vectors. Each
element of the list is a dictionary with a single key, “neighbors”, whose value is a
list of dicts that are the neighbors for that query vectory. The dict’s keys are the
columns in the database table (or only those you specified with any <code class="docutils literal notranslate"><span class="pre">*col_names</span></code>)
and an additional <code class="docutils literal notranslate"><span class="pre">&quot;metric&quot;</span></code> which holds the similarity between that neighbor and
the query vector.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">test_data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">records_gen</span><span class="p">(</span><span class="s2">&quot;sift-128-euclidean.hdf5&quot;</span><span class="p">,</span> <span class="n">test_data</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="s2">&quot;sift-128-euclidean.hdf5&quot;</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
<span class="n">true_neighbors</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;neighbors&quot;</span><span class="p">]</span>
<span class="n">true_distances</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="s2">&quot;distances&quot;</span><span class="p">]</span>

<span class="n">neighbors</span> <span class="o">=</span> <span class="n">vekter_db</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">test_data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;vector&quot;</span><span class="p">],</span> <span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;idx&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;neighbors&quot;</span><span class="p">]</span>
<span class="c1"># Let&#39;s see just the first neighbor</span>
<span class="nb">print</span><span class="p">(</span><span class="n">neighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>          <span class="c1"># {&#39;idx&#39;: 695756, &#39;metric&#39;: 258.86288}</span>

<span class="c1"># True nearest neighbor is</span>
<span class="nb">print</span><span class="p">(</span><span class="n">true_neighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># 932085</span>
<span class="nb">print</span><span class="p">(</span><span class="n">true_distances</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># 232.87122</span>
</pre></div>
</div>
<p>You will likely notice that the true nearest neighbor, idx=932085 with distance=232.87,
does NOT match the nearest record returned by our <code class="docutils literal notranslate"><span class="pre">search()</span></code> method.  For me, I get
idx=695756 with metric=258.86.</p>
<p>But don’t lose hope, because the search we did was using the default FAISS runtime
search parameters. For the “IVF_HNSW,PQ” index, this means we are using an <code class="docutils literal notranslate"><span class="pre">nprobe=1</span></code>
and <code class="docutils literal notranslate"><span class="pre">quantizer_efSearch=16</span></code>. With only searching the nearest partition choosen from
a candidate pool of 16, it is not surprising that our search failed to return the
expected neighbor. Typically, setting <code class="docutils literal notranslate"><span class="pre">nprobe</span></code> to 2 - 5% of the number of partitions
(5,000 for this index) yields acceptable results. We will use <code class="docutils literal notranslate"><span class="pre">nprobe=175</span></code> (3.5%). If
<code class="docutils literal notranslate"><span class="pre">nprobe=175</span></code>, then we should also increase <code class="docutils literal notranslate"><span class="pre">quantizer_efSearch</span></code> too so that the
candidate pool is bigger than <code class="docutils literal notranslate"><span class="pre">nprobe</span></code>. We will use <code class="docutils literal notranslate"><span class="pre">quantizer_efSearch=350</span></code> and
then retry our test query.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vekter_db</span><span class="o">.</span><span class="n">set_faiss_runtime_parameters</span><span class="p">(</span><span class="s2">&quot;nprobe=175,quantizer_efSearch=350&quot;</span><span class="p">)</span>

<span class="n">neighbors</span> <span class="o">=</span> <span class="n">vekter_db</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">test_data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;vector&quot;</span><span class="p">],</span> <span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;idx&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;neighbors&quot;</span><span class="p">]</span>
<span class="c1"># Let&#39;s see just the first neighbor</span>
<span class="nb">print</span><span class="p">(</span><span class="n">neighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>          <span class="c1"># {&#39;idx&#39;: 932085, &#39;metric&#39;: 232.87122}</span>

<span class="c1"># True nearest neighbor is</span>
<span class="nb">print</span><span class="p">(</span><span class="n">true_neighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># 932085</span>
<span class="nb">print</span><span class="p">(</span><span class="n">true_distances</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># 232.87122</span>
</pre></div>
</div>
<p>Now that is more like it! If you still don’t get the right answer, there are a few
additional things you can try. If we had been more aggressive with the PQ, say as low
as PQ8, then it’s possible that the estimated distances that FAISS uses to find the
nearest records is not great. In this case, you can increase the <code class="docutils literal notranslate"><span class="pre">k_extra_neighbors</span></code>
from 0 (default) to say 30. This will return 5 + 30 nearest vectors and then they will
be reranked based upon the true distance between the query vector and its neighbors
with only the top 5 after reranking returned to you. If that doesn’t work, you can
experiment with increase <code class="docutils literal notranslate"><span class="pre">nprobe</span></code> and/or <code class="docutils literal notranslate"><span class="pre">quantizer_efSearch</span></code> some more. But be
warned! Increase these values necessary slows down the querying time since more of
the data is being checked.</p>
<p>With a simple test done, let’s query with all the test data and see how we do with the
recall&#64;1 metric. That is, do we find the true nearest neighbor in our top 1 nearest
neighbor returned from the search?</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q_vecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">t</span><span class="p">[</span><span class="s2">&quot;vector&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">test_data</span><span class="p">])</span>

<span class="n">search_results</span> <span class="o">=</span> <span class="n">vekter_db</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">q_vecs</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;idx&quot;</span><span class="p">)</span>
<span class="n">found_nearest</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">search_result</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">search_results</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">true_neighbors</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">search_result</span><span class="p">[</span><span class="s2">&quot;neighbors&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;idx&quot;</span><span class="p">]:</span>
        <span class="n">found_nearest</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Recall@1 = </span><span class="si">{</span><span class="n">found_nearest</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="n">search_results</span><span class="p">)</span><span class="si">:</span><span class="s2">.04f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>In my running, I get a value of recall&#64;1 = 0.6646. This is ok, but maybe a little
disheartening. However, we only allowed FAISS to return the nearest approximate
neighbor and we have quite a few parameters to tweak if needed as we mentioned above.
We will start with raising the <code class="docutils literal notranslate"><span class="pre">k_extra_neighbors</span></code> value from 0 (default) to 4.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">search_results</span> <span class="o">=</span> <span class="n">vekter_db</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">q_vecs</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;idx&quot;</span><span class="p">,</span> <span class="n">k_extra_neighbors</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">found_nearest</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">search_result</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">search_results</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">true_neighbors</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">search_result</span><span class="p">[</span><span class="s2">&quot;neighbors&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;idx&quot;</span><span class="p">]:</span>
        <span class="n">found_nearest</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Recall@1 = </span><span class="si">{</span><span class="n">found_nearest</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="n">search_results</span><span class="p">)</span><span class="si">:</span><span class="s2">.04f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Much better. I got 0.9450. In fact, if we increase even further <code class="docutils literal notranslate"><span class="pre">k_extra_neighbors=49</span></code>,
then our result goes up to 0.9902. Again, our query time is increasing so it is always
a trade off. On my machine the query time for <code class="docutils literal notranslate"><span class="pre">q_vecs</span></code> went from 0.996s
(<code class="docutils literal notranslate"><span class="pre">k_extra_neighbors=0</span></code>) to 1.25s (4) to 3.47s (49).</p>
</section>
<section id="querying-for-similar-records">
<h3>Querying for Similar Records<a class="headerlink" href="#querying-for-similar-records" title="Permalink to this heading"></a></h3>
<p>In this section, we will show how to query for the nearest records of a given record
that is already in the database table. We begin by adding in the test vectors to our
database table and FAISS index. We will then repeat our simple test, but this time
using the <code class="docutils literal notranslate"><span class="pre">nearest_neighbors()</span></code> method.</p>
<p>This method allows you to select records whose nearest neighbors you are querying for
by specifying which column of the database to use <code class="docutils literal notranslate"><span class="pre">fetch_column</span></code> and then a list of
values whose records you want to use for querying, <code class="docutils literal notranslate"><span class="pre">fetch_values</span></code>. The rest follows
the same as <code class="docutils literal notranslate"><span class="pre">search()</span></code> since <code class="docutils literal notranslate"><span class="pre">nearest_neighbors</span></code> is just combining a
<code class="docutils literal notranslate"><span class="pre">fetch_records()</span></code> to retrieve the vectors of the request records and then using
<code class="docutils literal notranslate"><span class="pre">search()</span></code>. Caution is taken to remove the query record from the neighbors list.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">nearest_neighbors()</span></code> returns a list of dictionaries with each dictionary list
the query record’s values; either all the column values or just the values of the
columns names specified with <code class="docutils literal notranslate"><span class="pre">*col_names</span></code>. In addition, the “neighbors” key contains
the list of neighbors and the metric between the neighbor and the query record. This
list is sorted in appropriate order with nearest neighbor listed first.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">n_records</span> <span class="o">=</span> <span class="n">vekter_db</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
    <span class="n">test_data</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">50_000</span><span class="p">,</span> <span class="n">faiss_runtime_params</span><span class="o">=</span><span class="s2">&quot;quantizer_efSearch=25&quot;</span>
<span class="p">)</span>

<span class="n">neighbors</span> <span class="o">=</span> <span class="n">vekter_db</span><span class="o">.</span><span class="n">nearest_neighbors</span><span class="p">(</span><span class="s2">&quot;idx&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1_000_000</span><span class="p">],</span> <span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;idx&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span>
    <span class="s2">&quot;neighbors&quot;</span>
<span class="p">]</span>

<span class="k">if</span> <span class="n">true_neighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">neighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;idx&quot;</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;We found the true nearest neighbor!&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;       Found </span><span class="si">{</span><span class="n">neighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">ground_truth</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;idx&quot;</span><span class="p">:</span> <span class="n">true_neighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;metric&quot;</span><span class="p">:</span> <span class="n">true_distances</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]}</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Ground truth </span><span class="si">{</span><span class="n">ground_truth</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span>
        <span class="s2">&quot;Yikes! something still went wrong. Some things to try</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="o">+</span> <span class="s2">&quot;Increase the k_extra_neighbors from 0 to say 20.&quot;</span>
        <span class="o">+</span> <span class="s2">&quot; This pulls back some additional records and then reranks by true L2.&quot;</span>
        <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Or increase nprobe some more&quot;</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>Having passed the simple test, let’s do the full test data.  To mix things up, let’s
show that we can also use the <code class="docutils literal notranslate"><span class="pre">id</span></code> column to specify the records to fetch. Because
we had this column indexed in the specification of the database table, this should
equivalant as using the primary key, <code class="docutils literal notranslate"><span class="pre">idx</span></code>, of the database table.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">nn_results</span> <span class="o">=</span> <span class="n">vekter_db</span><span class="o">.</span><span class="n">nearest_neighbors</span><span class="p">(</span>
    <span class="s2">&quot;id&quot;</span><span class="p">,</span>
    <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1_000_000</span><span class="p">,</span> <span class="mi">1_010_000</span><span class="p">)],</span>
    <span class="mi">1</span><span class="p">,</span>
    <span class="s2">&quot;idx&quot;</span><span class="p">,</span>
    <span class="n">k_extra_neighbors</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">found_nearest</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">nn_result</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nn_results</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">true_neighbors</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">nn_result</span><span class="p">[</span><span class="s2">&quot;neighbors&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;idx&quot;</span><span class="p">]:</span>
        <span class="n">found_nearest</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">found_nearest</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="n">nn_results</span><span class="p">)</span><span class="si">:</span><span class="s2">.04f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>We get a recall&#64;1 = 0.9303 with these runtime search parameters and
<code class="docutils literal notranslate"><span class="pre">k_extra_neighbors</span></code> of 4. Notice that this value is a little lower than we had
before, 0.9450. This is caused by the additional 10,000 test vectors added into
the database table with a small percentage of them being the nearest neighbor for
other records in the test data.</p>
</section>
<section id="saving-loading-a-vekterdb">
<h3>Saving &amp; Loading a VekterDB<a class="headerlink" href="#saving-loading-a-vekterdb" title="Permalink to this heading"></a></h3>
<p>Having created a database table, populated it with records, created a FAISS index
(including both training it and adding in vectors from the database table), we are now
ready to save the VekterDB so that it can be loaded back up.</p>
<p>Since the records are already stored in the database, there is nothing to do there.
In fact, the FAISS index has also been saved off already as well. First right at the
end of <code class="docutils literal notranslate"><span class="pre">create_index()</span></code> and then again after we called <code class="docutils literal notranslate"><span class="pre">insert()</span></code> to add in the
test data. This leaves just saving off some of the metadata needed to reinitialize
<code class="docutils literal notranslate"><span class="pre">VekterDB</span></code> which is done using the <code class="docutils literal notranslate"><span class="pre">save()</span></code>.  This writes a JSON file to disk of
the needed information. If you don’t provide a <code class="docutils literal notranslate"><span class="pre">config_file</span></code> name, <code class="docutils literal notranslate"><span class="pre">save</span></code> will
write the file {table_name}.json to the local directory. In particular, this saves
off any default FAISS runtime search parameters that you may have set with
<code class="docutils literal notranslate"><span class="pre">set_faiss_runtime_parameters()</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vekter_db</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
<span class="k">del</span> <span class="n">vekter_db</span>
</pre></div>
</div>
<p>To test this, let’s exit out of the Python interpretter/IPython/Jupyter notebook and
import the needed libraries, load our <code class="docutils literal notranslate"><span class="pre">VekterDB</span></code> from disk, and then run a test
query.  Notice, that you do need to provide the connection URL to the database when
calling <code class="docutils literal notranslate"><span class="pre">load()</span></code>. This is done for security reasons since any username/password may
be needed to pass in that URL string that we don’t want to save to disk in plaintext.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vekter_db</span> <span class="o">=</span> <span class="n">VekterDB</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;tutorial.json&quot;</span><span class="p">,</span> <span class="n">url</span><span class="o">=</span><span class="s2">&quot;sqlite:///sift1m.db&quot;</span><span class="p">)</span>

<span class="n">nn_results</span> <span class="o">=</span> <span class="n">vekter_db</span><span class="o">.</span><span class="n">nearest_neighbors</span><span class="p">(</span>
    <span class="s2">&quot;id&quot;</span><span class="p">,</span>
    <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1_000_000</span><span class="p">,</span> <span class="mi">1_010_000</span><span class="p">)],</span>
    <span class="mi">1</span><span class="p">,</span>
    <span class="s2">&quot;idx&quot;</span><span class="p">,</span>
    <span class="n">k_extra_neighbors</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">found_nearest</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">nn_result</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nn_results</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">true_neighbors</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">nn_result</span><span class="p">[</span><span class="s2">&quot;neighbors&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;idx&quot;</span><span class="p">]:</span>
        <span class="n">found_nearest</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">found_nearest</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="n">nn_results</span><span class="p">)</span><span class="si">:</span><span class="s2">.04f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>And we get back the same 0.9303 for the recall&#64;1.</p>
<p class="rubric">Footnotes</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="f1" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>I. Doshi, D. Da, A. Bhutani, R. Kumar, R. Bhatt, N. Balasubramanian,
<em>LANNS: a web-scale approximate nearest neighbor lookup system</em>,
Proceedings of the VLDB Endowment <strong>15(4)</strong>, 850 (2021).
See also <a class="reference external" href="https://arxiv.org/abs/2010.09426">arXiv:2010.09426</a></p>
</aside>
<aside class="footnote brackets" id="f2" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p>C. Fu, C. Xiang, C. Wang, and D. Cai.
<em>Fast Approximate Nearest Neighbor Search With The Navigating Spreading-out Graph</em>,
<a class="reference external" href="https://arxiv.org/abs/1707.00143">arXiv:1707.00143</a>  (2017).</p>
</aside>
<aside class="footnote brackets" id="f3" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">3</a><span class="fn-bracket">]</span></span>
<p>B. Riggs and G. Williams,
<a class="reference external" href="https://medium.com/gsi-technology/ann-benchmarks-a-data-scientists-journey-to-billion-scale-performance-db191f043a27">ANN Benchmarks: A Data Scientist’s Journey to Billion Scale Performance</a>
(Note: they actually only tested on 54M vectors)</p>
</aside>
</aside>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="VekterDB" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="modules.html" class="btn btn-neutral float-right" title="vekterdb.vekterdb" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Matthew Hendrey.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>